export declare namespace tsutil {
    type BasePrimitive = string | number | boolean;
    type Primitive = BasePrimitive | BasePrimitive[];
    type isUndefined<T> = undefined extends T ? (T extends undefined ? true : false) : false;
    type isNull<T> = null extends T ? (T extends null ? true : false) : false;
    type isTrue<T> = true extends T ? (T extends true ? true : false) : false;
    type isFalse<T> = false extends T ? (T extends false ? true : false) : false;
    type isObject<T> = T extends {
        [k: string]: any;
    } ? (T extends Array<any> ? false : true) : false;
    type isObjectArray<T> = T extends Array<{
        [k: string]: any;
    }> ? true : false;
    type isEqual<T, U> = U extends T ? (T extends U ? true : false) : false;
    type stripNull<T> = T extends null ? never : T;
    type stripUndefined<T> = T extends undefined ? never : T;
    type flattenArray<T> = T extends (infer U)[] ? (any[] extends T ? U : T) : T;
    type require<T> = stripNull<stripUndefined<T>>;
    type clean<T> = flattenArray<stripNull<stripUndefined<T>>>;
    type cleanObject<T extends object> = flattenArray<stripNull<stripUndefined<T>>>;
    type variants<T> = T | T[] | undefined | null;
    type isOptional<T> = undefined extends T ? true : false;
    type isNullable<T> = null extends T ? true : false;
    type isArray<T> = any[] extends T ? true : false;
    type identity<T> = T;
    type neverKeys<T> = {
        [k in keyof T]: T[k] extends never ? k : never;
    }[keyof T];
    type Omit<T, K> = Pick<T, Exclude<keyof T, K>>;
    type noNever<T> = Omit<T, neverKeys<T>>;
    type flatten<T extends object> = identity<{
        [k in keyof noNever<T>]: T[k];
    }>;
    type format<T extends object> = identity<{
        [k in keyof T]: T[k];
    }>;
    interface Json {
        [key: string]: BasePrimitive | BasePrimitive[] | undefined | null | Json | Json[];
    }
    type typeToTuples<T> = T extends boolean ? [boolean | null | undefined] | [boolean[] | null | undefined] : [T | null | undefined] | [T[] | null | undefined];
    type nullableCheck<T, D extends {
        nullable: any;
    }> = D['nullable'] extends true ? T | null : T;
    type optionalCheck<T, D extends {
        optional: any;
    }> = D['optional'] extends true ? T | undefined : T;
    type arrayCheck<T, D extends {
        array: any;
    }> = D['array'] extends true ? T[] : T;
    type declean<T, D extends {
        nullable: boolean;
        optional: boolean;
        array: boolean;
    }> = optionalCheck<nullableCheck<arrayCheck<T, D>, D>, D>;
    type copyNullable<T, Y> = null extends Y ? T | null : T;
    type copyOptional<T, Y> = undefined extends Y ? T | undefined : T;
    type copyArray<T, Y> = any[] extends Y ? T[] : T;
    type toVariant<T, OriginalT> = copyNullable<copyOptional<copyArray<T, OriginalT>, OriginalT>, OriginalT>;
    type boxed<T> = [T];
    type nondistributed<T> = [T] extends [infer U] ? boxed<U> : never;
    type distributed<T> = T extends infer U ? boxed<U> : never;
    type isUnion<T> = distributed<T> extends nondistributed<T> ? nondistributed<T> extends distributed<T> ? false : true : true;
    type setKey<T extends object, Key extends string, Value extends any> = flatten<{
        [k in Exclude<keyof T, Key>]: T[k];
    } & {
        [k in Key]: Value;
    }>;
    type promisify<T> = T extends Promise<any> ? T : Promise<T>;
    type returnPromisify<T extends (...args: any) => any> = (...args: Parameters<T>) => ReturnType<T> extends Promise<any> ? ReturnType<T> : Promise<ReturnType<T>>;
    type makeOptional<T extends object, OptionalKeys extends keyof T = never> = {
        [k in Exclude<keyof T, OptionalKeys>]: T[k];
    } & {
        [k in OptionalKeys]?: T[k];
    };
    type getRequiredKeys<Shape extends object> = NonNullable<{
        [k in keyof Shape]: undefined extends Shape[k] ? never : k;
    }[keyof Shape]>;
    type getOptionalKeys<Shape extends object> = Exclude<keyof Shape, getRequiredKeys<Shape>>;
    type setDefaults<Shape extends object, Defaults extends {
        [k: string]: any;
    }> = flatten<{
        [k in getRequiredKeys<Shape>]: Shape[k];
    } & {
        [k in Exclude<keyof Defaults, getRequiredKeys<Shape>>]: Defaults[k];
    }>;
    type filterByClass<T, Class> = flatten<{
        [k in keyof clean<T>]: clean<T>[k] extends Class ? clean<T>[k] : never;
    }>;
    type filterByNotClass<T, Class> = flatten<{
        [k in keyof clean<T>]: clean<T>[k] extends Class ? never : clean<T>[k];
    }>;
    type merge<A extends object, B extends object> = {
        [k in Exclude<keyof A, keyof B>]: A[k];
    } & B;
    function assertNever(_x: never): never;
}
