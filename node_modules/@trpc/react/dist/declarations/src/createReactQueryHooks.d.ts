import { CreateTRPCClientOptions, OperationContext, TRPCClient, TRPCClientError } from '@trpc/client';
import type { AnyRouter, inferHandlerInput, inferProcedureInput } from '@trpc/server';
import { ReactNode } from 'react';
import { QueryClient, QueryKey, UseInfiniteQueryOptions, UseMutationOptions, UseQueryOptions, UseQueryResult } from 'react-query';
import { DehydratedState } from 'react-query/hydration';
import { TRPCContextState } from './internals/context';
export declare type OutputWithCursor<TData, TCursor extends any = any> = {
    cursor: TCursor | null;
    data: TData;
};
interface TRPCUseQueryBaseOptions {
    /**
     * Opt out of SSR for this query by passing `ssr: false`
     */
    ssr?: boolean;
    /**
     * Pass additional context to links
     */
    context?: OperationContext;
}
interface UseTRPCQueryOptions<TInput, TError, TOutput> extends UseQueryOptions<TInput, TError, TOutput, QueryKey>, TRPCUseQueryBaseOptions {
}
interface UseTRPCInfiniteQueryOptions<TInput = unknown, TError = unknown, TOutput = TInput> extends UseInfiniteQueryOptions<TInput, TError, TOutput, TOutput, QueryKey>, TRPCUseQueryBaseOptions {
}
interface UseTRPCMutationOptions<TInput, TError, TOutput> extends UseMutationOptions<TOutput, TError, TInput>, TRPCUseQueryBaseOptions {
}
export declare function createReactQueryHooks<TRouter extends AnyRouter>(): {
    Provider: ({ client, queryClient, children, isPrepass, }: {
        queryClient: QueryClient;
        client: TRPCClient<TRouter>;
        children: ReactNode;
        isPrepass?: boolean | undefined;
    }) => JSX.Element;
    createClient: (opts: CreateTRPCClientOptions<TRouter>) => TRPCClient<TRouter>;
    useContext: () => TRPCContextState<TRouter>;
    useQuery: <TPath extends keyof TRouter["_def"]["queries"] & string, TProcedure extends TRouter["_def"]["queries"][TPath], TOutput extends import("@trpc/server").ThenArg<ReturnType<TProcedure["call"]>>>(pathAndArgs: [path: TPath, ...args: inferHandlerInput<TProcedure>], opts?: UseTRPCQueryOptions<inferProcedureInput<TRouter["_def"]["queries"][TPath]>, TRPCClientError<TRouter>, TOutput> | undefined) => UseQueryResult<TOutput, TRPCClientError<TRouter>>;
    useMutation: <TPath_1 extends keyof TRouter["_def"]["mutations"] & string, TInput extends inferProcedureInput<TRouter["_def"]["mutations"][TPath_1]>, TOutput_1 extends import("@trpc/server").ThenArg<ReturnType<TRouter["_def"]["mutations"][TPath_1]["call"]>>>(path: TPath_1, opts?: UseTRPCMutationOptions<TInput, TRPCClientError<TRouter>, TOutput_1> | undefined) => import("react-query").UseMutationResult<TOutput_1, TRPCClientError<TRouter>, TInput, unknown>;
    useSubscription: <TPath_2 extends keyof TRouter["_def"]["subscriptions"] & string, TInput_1 extends inferProcedureInput<TRouter["_def"]["subscriptions"][TPath_2]>, TOutput_2 extends ReturnType<import("@trpc/server").ThenArg<ReturnType<TRouter["_def"]["subscriptions"][TPath_2]["call"]>>["output"]>>(pathAndArgs: [TPath_2, TInput_1], opts?: {
        enabled?: boolean | undefined;
        onError?: ((err: TRPCClientError<TRouter>) => void) | undefined;
        onBatch?: ((data: TOutput_2[]) => void) | undefined;
    } | undefined) => void;
    useLiveQuery: <TPath_3 extends keyof TRouter["_def"]["subscriptions"] & string, TInput_2 extends inferProcedureInput<TRouter["_def"]["subscriptions"][TPath_3]> & {
        cursor: any;
    }, TOutput_3 extends (ReturnType<import("@trpc/server").ThenArg<ReturnType<TRouter["_def"]["subscriptions"][TPath_3]["call"]>>["output"]> & OutputWithCursor<TData, any>)[], TData>(pathAndArgs: [TPath_3, Omit<TInput_2, "cursor">], opts?: Omit<UseQueryOptions<TInput_2, TRPCClientError<TRouter>, TOutput_3, QueryKey>, "select"> | undefined) => {
        data: TOutput_3[number]["data"] | undefined;
        error: null;
        isError: false;
        isIdle: true;
        isLoading: false;
        isLoadingError: false;
        isRefetchError: false;
        isSuccess: false;
        status: "idle";
        dataUpdatedAt: number;
        errorUpdatedAt: number;
        failureCount: number;
        isFetched: boolean;
        isFetchedAfterMount: boolean;
        isFetching: boolean;
        isPlaceholderData: boolean;
        isPreviousData: boolean;
        isStale: boolean;
        refetch: (options?: import("react-query").RefetchOptions | undefined) => Promise<import("react-query").QueryObserverResult<TOutput_3, TRPCClientError<TRouter>>>;
        remove: () => void;
    } | {
        data: TOutput_3[number]["data"] | undefined;
        error: TRPCClientError<TRouter>;
        isError: true;
        isIdle: false;
        isLoading: false;
        isLoadingError: true;
        isRefetchError: false;
        isSuccess: false;
        status: "error";
        dataUpdatedAt: number;
        errorUpdatedAt: number;
        failureCount: number;
        isFetched: boolean;
        isFetchedAfterMount: boolean;
        isFetching: boolean;
        isPlaceholderData: boolean;
        isPreviousData: boolean;
        isStale: boolean;
        refetch: (options?: import("react-query").RefetchOptions | undefined) => Promise<import("react-query").QueryObserverResult<TOutput_3, TRPCClientError<TRouter>>>;
        remove: () => void;
    } | {
        data: TOutput_3[number]["data"] | undefined;
        error: null;
        isError: false;
        isIdle: false;
        isLoading: true;
        isLoadingError: false;
        isRefetchError: false;
        isSuccess: false;
        status: "loading";
        dataUpdatedAt: number;
        errorUpdatedAt: number;
        failureCount: number;
        isFetched: boolean;
        isFetchedAfterMount: boolean;
        isFetching: boolean;
        isPlaceholderData: boolean;
        isPreviousData: boolean;
        isStale: boolean;
        refetch: (options?: import("react-query").RefetchOptions | undefined) => Promise<import("react-query").QueryObserverResult<TOutput_3, TRPCClientError<TRouter>>>;
        remove: () => void;
    } | {
        data: TOutput_3[number]["data"] | undefined;
        error: TRPCClientError<TRouter>;
        isError: true;
        isIdle: false;
        isLoading: false;
        isLoadingError: false;
        isRefetchError: true;
        isSuccess: false;
        status: "error";
        dataUpdatedAt: number;
        errorUpdatedAt: number;
        failureCount: number;
        isFetched: boolean;
        isFetchedAfterMount: boolean;
        isFetching: boolean;
        isPlaceholderData: boolean;
        isPreviousData: boolean;
        isStale: boolean;
        refetch: (options?: import("react-query").RefetchOptions | undefined) => Promise<import("react-query").QueryObserverResult<TOutput_3, TRPCClientError<TRouter>>>;
        remove: () => void;
    } | {
        data: TOutput_3[number]["data"] | undefined;
        error: null;
        isError: false;
        isIdle: false;
        isLoading: false;
        isLoadingError: false;
        isRefetchError: false;
        isSuccess: true;
        status: "success";
        dataUpdatedAt: number;
        errorUpdatedAt: number;
        failureCount: number;
        isFetched: boolean;
        isFetchedAfterMount: boolean;
        isFetching: boolean;
        isPlaceholderData: boolean;
        isPreviousData: boolean;
        isStale: boolean;
        refetch: (options?: import("react-query").RefetchOptions | undefined) => Promise<import("react-query").QueryObserverResult<TOutput_3, TRPCClientError<TRouter>>>;
        remove: () => void;
    };
    useDehydratedState: (client: TRPCClient<TRouter>, trpcState: DehydratedState | undefined) => DehydratedState | undefined;
    useInfiniteQuery: <TPath_4 extends keyof TRouter["_def"]["queries"] & string, TInput_3 extends inferProcedureInput<TRouter["_def"]["queries"][TPath_4]> & {
        cursor: TCursor;
    }, TOutput_4 extends import("@trpc/server").ThenArg<ReturnType<TRouter["_def"]["queries"][TPath_4]["call"]>>, TCursor extends unknown>(pathAndArgs: [TPath_4, Omit<TInput_3, "cursor">], opts?: UseTRPCInfiniteQueryOptions<TOutput_4, TRPCClientError<TRouter>, TOutput_4> | undefined) => import("react-query").UseInfiniteQueryResult<TOutput_4, TRPCClientError<TRouter>>;
};
export {};
