'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var client = require('@trpc/client');
var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var _slicedToArray = require('@babel/runtime/helpers/slicedToArray');
var _toConsumableArray = require('@babel/runtime/helpers/toConsumableArray');
var React = require('react');
var reactQuery = require('react-query');
var getCacheKey = require('./getCacheKey-5ace4ef2.cjs.prod.js');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefault(React);

var TRPCContext = /*#__PURE__*/React.createContext(null);

function createReactQueryHooks() {
  var Context = TRPCContext;

  function createClient(opts) {
    return client.createTRPCClient(opts);
  }

  function TRPCProvider(_ref) {
    var client = _ref.client,
        queryClient = _ref.queryClient,
        children = _ref.children,
        _ref$isPrepass = _ref.isPrepass,
        isPrepass = _ref$isPrepass === void 0 ? false : _ref$isPrepass;
    return /*#__PURE__*/React__default['default'].createElement(Context.Provider, {
      value: {
        queryClient: queryClient,
        client: client,
        isPrepass: isPrepass,
        fetchQuery: React.useCallback(function (pathAndArgs, opts) {
          var cacheKey = getCacheKey.getCacheKey(pathAndArgs, getCacheKey.CACHE_KEY_QUERY);
          return queryClient.fetchQuery(cacheKey, function () {
            return client.query.apply(client, _toConsumableArray(pathAndArgs));
          }, opts);
        }, [client, queryClient]),
        fetchInfiniteQuery: React.useCallback(function (pathAndArgs, opts) {
          var cacheKey = getCacheKey.getCacheKey(pathAndArgs, getCacheKey.CACHE_KEY_INFINITE_QUERY);
          return queryClient.fetchInfiniteQuery(cacheKey, function () {
            return client.query.apply(client, _toConsumableArray(pathAndArgs));
          }, opts);
        }, [client, queryClient]),
        prefetchQuery: React.useCallback(function (pathAndArgs, opts) {
          var cacheKey = getCacheKey.getCacheKey(pathAndArgs, getCacheKey.CACHE_KEY_QUERY);
          return queryClient.prefetchQuery(cacheKey, function () {
            return client.query.apply(client, _toConsumableArray(pathAndArgs));
          }, opts);
        }, [client, queryClient]),
        prefetchInfiniteQuery: React.useCallback(function (pathAndArgs, opts) {
          var cacheKey = getCacheKey.getCacheKey(pathAndArgs, getCacheKey.CACHE_KEY_INFINITE_QUERY);
          return queryClient.prefetchInfiniteQuery(cacheKey, function () {
            return client.query.apply(client, _toConsumableArray(pathAndArgs));
          }, opts);
        }, [client, queryClient]),
        invalidateQuery: React.useCallback(function (pathAndArgs) {
          var cacheKey = getCacheKey.getCacheKey(pathAndArgs);
          return queryClient.invalidateQueries(cacheKey);
        }, [queryClient]),
        cancelQuery: React.useCallback(function (pathAndArgs) {
          var cacheKey = getCacheKey.getCacheKey(pathAndArgs);
          return queryClient.cancelQueries(cacheKey);
        }, [queryClient]),
        setQueryData: React.useCallback(function (pathAndArgs, output) {
          var cacheKey = getCacheKey.getCacheKey(pathAndArgs);
          queryClient.setQueryData(cacheKey.concat([getCacheKey.CACHE_KEY_QUERY]), output);
          queryClient.setQueryData(cacheKey.concat([getCacheKey.CACHE_KEY_INFINITE_QUERY]), output);
        }, [queryClient])
      }
    }, children);
  }

  function useContext() {
    return React__default['default'].useContext(Context);
  }

  function _useQuery(pathAndArgs, opts) {
    var cacheKey = getCacheKey.getCacheKey(pathAndArgs, getCacheKey.CACHE_KEY_QUERY);

    var _useContext = useContext(),
        client = _useContext.client,
        isPrepass = _useContext.isPrepass,
        queryClient = _useContext.queryClient,
        fetchQuery = _useContext.fetchQuery;

    if (typeof window === 'undefined' && isPrepass && (opts === null || opts === void 0 ? void 0 : opts.ssr) !== false && !queryClient.getQueryCache().find(cacheKey)) {
      fetchQuery(pathAndArgs);
    }

    var query = reactQuery.useQuery(cacheKey, function () {
      return client.query.apply(client, _toConsumableArray(pathAndArgs));
    }, opts);
    return query;
  }

  function _useMutation(path, opts) {
    var client = useContext().client;
    var hook = reactQuery.useMutation(function (input) {
      return client.mutation(path, input);
    }, opts);
    return hook;
  }
  /* istanbul ignore next */

  /**
   * ⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️
   *  **Experimental.** API might change without major version bump
   * ⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠
   */


  function useSubscription(pathAndArgs, opts) {
    var _opts$enabled;

    var enabled = (_opts$enabled = opts === null || opts === void 0 ? void 0 : opts.enabled) !== null && _opts$enabled !== void 0 ? _opts$enabled : true;
    var queryKey = reactQuery.hashQueryKey(pathAndArgs);
    var client = useContext().client;
    return React.useEffect(function () {
      if (!enabled) {
        return;
      }

      var stopped = false;

      var _pathAndArgs = _slicedToArray(pathAndArgs, 2),
          path = _pathAndArgs[0],
          input = _pathAndArgs[1];

      var promise = client.subscriptionOnce(path, input);
      promise.then(function (data) {
        if (stopped) {
          return;
        }

        (opts === null || opts === void 0 ? void 0 : opts.onBatch) && opts.onBatch(data);
      }).catch(function (err) {
        if (stopped) {
          return;
        }

        (opts === null || opts === void 0 ? void 0 : opts.onError) && opts.onError(err);
      });
      return function () {
        stopped = true;
        promise.cancel();
      }; // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [queryKey, enabled]);
  }
  /* istanbul ignore next */

  /**
   * ⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️
   *  **Experimental.** API might change without major version bump
   * ⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠
   */


  function useLiveQuery(pathAndArgs, opts) {
    var _pathAndArgs2 = _slicedToArray(pathAndArgs, 2),
        path = _pathAndArgs2[0],
        userInput = _pathAndArgs2[1];

    var currentCursor = React.useRef(null);
    var cacheKey = getCacheKey.getCacheKey(pathAndArgs, getCacheKey.CACHE_KEY_LIVE_QUERY);
    var client = useContext().client;
    var hook = reactQuery.useQuery(cacheKey, function () {
      return client.subscriptionOnce(path, _objectSpread(_objectSpread({}, userInput), {}, {
        cursor: currentCursor.current
      }));
    }, opts);
    var lastItem = React.useMemo(function () {
      var raw = hook.data;

      if (typeof raw === 'undefined') {
        return undefined;
      }

      var last = raw[raw.length - 1];
      return last;
    }, [hook.data]);
    var data = lastItem === null || lastItem === void 0 ? void 0 : lastItem.data;
    var lastCursor = lastItem === null || lastItem === void 0 ? void 0 : lastItem.cursor;
    React.useEffect(function () {
      currentCursor.current = lastCursor;
      hook.refetch(); // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [lastCursor]);
    return _objectSpread(_objectSpread({}, hook), {}, {
      data: data
    });
  }

  function _useInfiniteQuery(pathAndArgs, // FIXME: this typing is wrong but it works
  opts) {
    var _useContext2 = useContext(),
        client = _useContext2.client,
        isPrepass = _useContext2.isPrepass,
        fetchInfiniteQuery = _useContext2.fetchInfiniteQuery,
        queryClient = _useContext2.queryClient;

    var cacheKey = getCacheKey.getCacheKey(pathAndArgs, getCacheKey.CACHE_KEY_INFINITE_QUERY);

    var _pathAndArgs3 = _slicedToArray(pathAndArgs, 2),
        path = _pathAndArgs3[0],
        input = _pathAndArgs3[1];

    if (typeof window === 'undefined' && isPrepass && (opts === null || opts === void 0 ? void 0 : opts.ssr) !== false && !queryClient.getQueryCache().find(cacheKey)) {
      fetchInfiniteQuery(pathAndArgs);
    }

    var query = reactQuery.useInfiniteQuery(cacheKey, function (_ref2) {
      var pageParam = _ref2.pageParam;

      var actualInput = _objectSpread(_objectSpread({}, input), {}, {
        cursor: pageParam
      });

      return client.query(path, actualInput);
    }, opts);
    return query;
  }

  function useDehydratedState(client, trpcState) {
    var transformed = React.useMemo(function () {
      if (!trpcState) {
        return trpcState;
      }

      return client.runtime.transformer.deserialize(trpcState);
    }, [client, trpcState]);
    return transformed;
  }

  return {
    Provider: TRPCProvider,
    createClient: createClient,
    useContext: useContext,
    useQuery: _useQuery,
    useMutation: _useMutation,
    useSubscription: useSubscription,
    useLiveQuery: useLiveQuery,
    useDehydratedState: useDehydratedState,
    useInfiniteQuery: _useInfiniteQuery
  };
}

exports.createReactQueryHooks = createReactQueryHooks;
Object.keys(client).forEach(function (k) {
  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () {
      return client[k];
    }
  });
});
