/// <reference types="node" />
import http from 'http';
import qs from 'qs';
import { TRPCError } from '../errors';
import { AnyRouter, inferRouterContext, ProcedureType } from '../router';
import { DataTransformerOptions } from '../transformer';
export declare type CreateContextFnOptions<TRequest, TResponse> = {
    req: TRequest;
    res: TResponse;
};
export declare type CreateContextFn<TRouter extends AnyRouter, TRequest, TResponse> = (opts: CreateContextFnOptions<TRequest, TResponse>) => inferRouterContext<TRouter> | Promise<inferRouterContext<TRouter>>;
export declare type BaseRequest = http.IncomingMessage & {
    method?: string;
    query?: qs.ParsedQs;
    body?: any;
};
export declare type BaseResponse = http.ServerResponse;
export interface BaseOptions<TRouter extends AnyRouter, TRequest extends BaseRequest> {
    subscriptions?: {
        /**
         * Time in milliseconds before `408` is sent
         */
        requestTimeoutMs?: number;
        /**
         * Allow for some backpressure and batch send events every X ms
         */
        backpressureMs?: number;
    };
    teardown?: () => Promise<void>;
    /**
     * @deprecated use `router.transformer()`
     */
    transformer?: DataTransformerOptions;
    maxBodySize?: number;
    onError?: (opts: {
        error: TRPCError;
        type: ProcedureType | 'unknown';
        path: string | undefined;
        req: TRequest;
        input: unknown;
        ctx: undefined | inferRouterContext<TRouter>;
    }) => void;
    batching?: {
        enabled: boolean;
    };
}
export declare function requestHandler<TRouter extends AnyRouter, TCreateContextFn extends CreateContextFn<TRouter, TRequest, TResponse>, TRequest extends BaseRequest, TResponse extends BaseResponse>(opts: {
    req: TRequest;
    res: TResponse;
    path: string;
    router: TRouter;
    createContext: TCreateContextFn;
} & BaseOptions<TRouter, TRequest>): Promise<void>;
