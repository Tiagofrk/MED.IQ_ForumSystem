'use strict';

var TRPCError = require('../error/TRPCError.js');
var utils = require('../utils.js');
var tracked = require('./tracked.js');
var createDeferred = require('./utils/createDeferred.js');
var createReadableStream = require('./utils/createReadableStream.js');

const SERIALIZED_ERROR_EVENT = 'serialized-error';
/**
 *
 * @see https://html.spec.whatwg.org/multipage/server-sent-events.html
 */ function sseStreamProducer(opts) {
    const stream = createReadableStream.createReadableStream();
    stream.controller.enqueue({
        comment: 'connected'
    });
    const { serialize =(v)=>v  } = opts;
    const ping = {
        enabled: opts.ping?.enabled ?? false,
        intervalMs: opts.ping?.intervalMs ?? 1000
    };
    utils.run(async ()=>{
        const iterator = opts.data[Symbol.asyncIterator]();
        const closedPromise = stream.cancelledPromise.then(()=>'closed');
        const maxDurationPromise = createDeferred.createTimeoutPromise(opts.maxDurationMs ?? Infinity, 'maxDuration');
        let nextPromise = iterator.next();
        while(true){
            const pingPromise = createDeferred.createTimeoutPromise(ping.enabled ? ping.intervalMs : Infinity, 'ping');
            const next = await Promise.race([
                nextPromise.catch(TRPCError.getTRPCErrorFromUnknown),
                pingPromise.promise,
                closedPromise,
                maxDurationPromise.promise
            ]);
            pingPromise.clear();
            if (next === 'closed') {
                break;
            }
            if (next === 'maxDuration') {
                break;
            }
            if (next === 'ping') {
                stream.controller.enqueue({
                    comment: 'ping'
                });
                continue;
            }
            if (next instanceof Error) {
                const data = opts.formatError ? opts.formatError({
                    error: next
                }) : null;
                stream.controller.enqueue({
                    event: SERIALIZED_ERROR_EVENT,
                    data: JSON.stringify(serialize(data))
                });
                break;
            }
            if (next.done) {
                break;
            }
            const value = next.value;
            const chunk = tracked.isTrackedEnvelope(value) ? {
                id: value[0],
                data: value[1]
            } : {
                data: value
            };
            if ('data' in chunk) {
                chunk.data = JSON.stringify(serialize(chunk.data));
            }
            stream.controller.enqueue(chunk);
            if (opts.emitAndEndImmediately) {
                // end the stream in the next tick so that we can send a few more events from the queue
                setTimeout(maxDurationPromise.resolve, 1);
            }
            nextPromise = iterator.next();
        }
        maxDurationPromise.clear();
        await iterator.return?.();
        try {
            stream.controller.close();
        } catch  {}
    }).catch((error)=>{
        return stream.controller.error(error);
    });
    return stream.readable.pipeThrough(new TransformStream({
        transform (chunk, controller) {
            if ('event' in chunk) {
                controller.enqueue(`event: ${chunk.event}\n`);
            }
            if ('data' in chunk) {
                controller.enqueue(`data: ${chunk.data}\n`);
            }
            if ('id' in chunk) {
                controller.enqueue(`id: ${chunk.id}\n`);
            }
            if ('comment' in chunk) {
                controller.enqueue(`: ${chunk.comment}\n`);
            }
            controller.enqueue('\n\n');
        }
    }));
}
/**
 * @see https://html.spec.whatwg.org/multipage/server-sent-events.html
 */ function sseStreamConsumer(opts) {
    const { deserialize =(v)=>v , shouldRecreateOnError  } = opts;
    const signal = opts.signal;
    let eventSource = null;
    let lock = null;
    const stream = createReadableStream.createReadableStream();
    function createEventSource(...args) {
        const es = new EventSource(...args);
        if (signal.aborted) {
            es.close();
        } else {
            signal.addEventListener('abort', ()=>es.close());
        }
        /**
     * Dispatch an event to the stream controller
     *
     * Will be a no-op if the event source has been replaced
     */ const dispatch = (fn)=>{
            utils.run(async ()=>{
                while(lock){
                    await lock;
                }
                if (es === eventSource) {
                    await fn(stream.controller);
                }
            }).catch((error)=>{
                stream.controller.error(error);
            });
        };
        const pauseDispatch = async (fn)=>{
            while(lock){
                await lock;
            }
            if (es !== eventSource) {
                return;
            }
            const deferred = createDeferred.createDeferred();
            lock = deferred.promise;
            try {
                await fn();
            } finally{
                lock = null;
                deferred.resolve();
            }
        };
        es.addEventListener('open', ()=>{
            dispatch((controller)=>{
                controller.enqueue({
                    type: 'opened',
                    eventSource: es
                });
            });
        });
        es.addEventListener(SERIALIZED_ERROR_EVENT, (msg)=>{
            dispatch(async ()=>{
                if (shouldRecreateOnError) {
                    await pauseDispatch(async ()=>{
                        const recreate = await shouldRecreateOnError({
                            type: SERIALIZED_ERROR_EVENT,
                            error: deserialize(JSON.parse(msg.data))
                        });
                        if (recreate) {
                            await recreateEventSource();
                        }
                    });
                }
                dispatch((controller)=>{
                    controller.enqueue({
                        type: 'error',
                        error: deserialize(JSON.parse(msg.data)),
                        eventSource: es
                    });
                });
            });
        });
        es.addEventListener('error', (event)=>{
            dispatch(async ()=>{
                if (shouldRecreateOnError) {
                    await pauseDispatch(async ()=>{
                        const recreate = await shouldRecreateOnError({
                            type: 'event',
                            event
                        });
                        if (recreate) {
                            await recreateEventSource();
                        }
                    });
                }
                dispatch((controller)=>{
                    if (es.readyState === EventSource.CLOSED) {
                        controller.error(event);
                    } else {
                        controller.enqueue({
                            type: 'connecting',
                            eventSource: es
                        });
                    }
                });
            });
        });
        es.addEventListener('message', (msg)=>{
            dispatch((controller)=>{
                const chunk = deserialize(JSON.parse(msg.data));
                const def = {
                    data: chunk
                };
                if (msg.lastEventId) {
                    def.id = msg.lastEventId;
                }
                controller.enqueue({
                    type: 'data',
                    data: def,
                    eventSource: es
                });
            });
        });
        return es;
    }
    async function recreateEventSource() {
        eventSource?.close();
        const [url, init] = await Promise.all([
            opts.url(),
            opts.init()
        ]);
        eventSource = createEventSource(url, init);
        stream.controller.enqueue({
            type: 'connecting',
            eventSource
        });
    }
    recreateEventSource().catch(()=>{
    // prevent unhandled promise rejection
    });
    return {
        [Symbol.asyncIterator] () {
            const reader = stream.readable.getReader();
            const iterator = {
                async next () {
                    const value = await reader.read();
                    if (value.done) {
                        return {
                            value: undefined,
                            done: true
                        };
                    }
                    return {
                        value: value.value,
                        done: false
                    };
                },
                async return () {
                    reader.releaseLock();
                    return {
                        value: undefined,
                        done: true
                    };
                }
            };
            return iterator;
        }
    };
}
const sseHeaders = {
    'Content-Type': 'text/event-stream',
    'Cache-Control': 'no-cache, no-transform',
    'X-Accel-Buffering': 'no',
    Connection: 'keep-alive'
};

exports.sseHeaders = sseHeaders;
exports.sseStreamConsumer = sseStreamConsumer;
exports.sseStreamProducer = sseStreamProducer;
