'use strict';

var url = require('url');
var once = require('./once-7f92f88f.cjs.prod.js');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var url__default = /*#__PURE__*/_interopDefault(url);

/* istanbul ignore file */
function assertNotBrowser() {
  if (typeof window !== 'undefined' &&         "production" !== 'test' && process.env.JEST_WORKER_ID === undefined) {
    throw new Error('Imported server-only code in the broowser');
  }
}

const STATUS_CODE_MAP = {
  BAD_USER_INPUT: 400,
  INTERAL_SERVER_ERROR: 500,
  NOT_FOUND: 404
};
class HTTPError extends once.TRPCError {
  constructor(message, opts) {
    super({
      message,
      ...opts
    });
    this.statusCode = void 0;
    this.statusCode = opts.statusCode; // this is set to TRPCError as `instanceof TRPCError` doesn't seem to work on error sub-classes

    Object.setPrototypeOf(this, HTTPError.prototype);
  }

}
/* istanbul ignore next */

const httpError = {
  forbidden: message => new HTTPError(message !== null && message !== void 0 ? message : 'Forbidden', {
    statusCode: 403,
    code: 'FORBIDDEN'
  }),
  unauthorized: message => new HTTPError(message !== null && message !== void 0 ? message : 'Unauthorized', {
    statusCode: 401,
    code: 'UNAUTHENTICATED'
  }),
  badRequest: message => new HTTPError(message !== null && message !== void 0 ? message : 'Bad Request', {
    statusCode: 400,
    code: 'BAD_USER_INPUT'
  }),
  notFound: message => new HTTPError(message !== null && message !== void 0 ? message : 'Not found', {
    statusCode: 404,
    code: 'NOT_FOUND'
  })
};
function getStatusCodeFromError(err) {
  var _STATUS_CODE_MAP$err$;

  const statusCodeFromError = err === null || err === void 0 ? void 0 : err.statusCode;

  if (typeof statusCodeFromError === 'number') {
    return statusCodeFromError;
  }

  return (_STATUS_CODE_MAP$err$ = STATUS_CODE_MAP[err.code]) !== null && _STATUS_CODE_MAP$err$ !== void 0 ? _STATUS_CODE_MAP$err$ : 500;
}

async function getPostBody({
  req,
  maxBodySize
}) {
  return new Promise((resolve, reject) => {
    if (req.hasOwnProperty('body')) {
      resolve(req.body);
      return;
    }

    let body = '';
    req.on('data', function (data) {
      body += data;

      if (typeof maxBodySize === 'number' && body.length > maxBodySize) {
        reject(new HTTPError('Payload Too Large', {
          statusCode: 413,
          code: 'BAD_USER_INPUT'
        }));
        req.socket.destroy();
      }
    });
    req.on('end', () => {
      try {
        const json = JSON.parse(body);
        resolve(json);
      } catch (err) {
        reject(new HTTPError("Body couldn't be parsed as json", {
          statusCode: 400,
          code: 'BAD_USER_INPUT'
        }));
      }
    });
  });
}

function getQueryInput(query) {
  const queryInput = query.input;

  if (!queryInput) {
    return undefined;
  }

  try {
    return JSON.parse(queryInput);
  } catch (err) {
    throw once.inputValidationError('Expected query.input to be a JSON string');
  }
}

/* eslint-disable @typescript-eslint/no-non-null-assertion */
assertNotBrowser();
const HTTP_METHOD_PROCEDURE_TYPE_MAP = {
  GET: 'query',
  POST: 'mutation',
  PATCH: 'subscription'
};
/**
 * Resolve input from request
 */

async function getInputFromRequest({
  req,
  type,
  maxBodySize
}) {
  if (type === 'query') {
    const query = req.query ? req.query : url__default['default'].parse(req.url, true).query;
    const input = getQueryInput(query);
    return input;
  }

  const body = await getPostBody({
    req,
    maxBodySize
  });
  return body.input;
}
/**
 * Call procedure and get output
 */


async function callProcedure(opts) {
  const {
    type,
    path,
    input,
    subscriptions,
    caller,
    events: events
  } = opts;

  if (type === 'query') {
    return caller.query(path, input);
  }

  if (type === 'mutation') {
    return caller.mutation(path, input);
  }

  if (type === 'subscription') {
    const sub = await caller.subscription(path, input);
    return new Promise((resolve, reject) => {
      var _subscriptions$reques, _subscriptions$backpr;

      const startTime = Date.now();
      const buffer = [];
      const requestTimeoutMs = (_subscriptions$reques = subscriptions === null || subscriptions === void 0 ? void 0 : subscriptions.requestTimeoutMs) !== null && _subscriptions$reques !== void 0 ? _subscriptions$reques : 9000; // 10s is vercel's api timeout

      const backpressureMs = (_subscriptions$backpr = subscriptions === null || subscriptions === void 0 ? void 0 : subscriptions.backpressureMs) !== null && _subscriptions$backpr !== void 0 ? _subscriptions$backpr : 0; // timers

      let backpressureTimer = null;
      let requestTimeoutTimer = null;

      function cleanup() {
        sub.off('data', onData);
        sub.off('error', onError);
        sub.off('destroy', onDestroy);
        events.off('close', onClose);
        events.off('flush', flush);
        clearTimeout(requestTimeoutTimer);
        clearTimeout(backpressureTimer);
        sub.destroy();
      }

      const flush = () => {
        cleanup();
        resolve(buffer);
      };

      function onData(data) {
        buffer.push(data);
        const requestTimeLeft = requestTimeoutMs - (Date.now() - startTime);

        if (requestTimeLeft <= backpressureMs) {
          // will timeout before next backpressure tick
          flush();
          return;
        }

        if (!backpressureTimer) {
          backpressureTimer = setTimeout(flush, backpressureMs);
          return;
        }
      }

      function onError(err) {
        cleanup(); // maybe if `buffer` has length here we should just return instead?

        reject(err);
      }

      function onClose() {
        cleanup();
        reject(new HTTPError(`Client Closed Request`, {
          statusCode: 499,
          code: 'BAD_USER_INPUT'
        }));
      }

      function onRequestTimeout() {
        cleanup();
        reject(new HTTPError(`Subscription exceeded ${requestTimeoutMs}ms - please reconnect.`, {
          statusCode: 408,
          code: 'TIMEOUT'
        }));
      }

      function onDestroy() {
        reject(new Error(`Subscription was destroyed prematurely`));
        cleanup();
      }

      sub.on('data', onData);
      sub.on('error', onError);
      sub.on('destroy', onDestroy);
      events.once('close', onClose);
      events.once('flush', flush);
      requestTimeoutTimer = setTimeout(onRequestTimeout, requestTimeoutMs);
      sub.start();
    });
  }

  throw new Error(`Unknown procedure type ${type}`);
}

async function requestHandler(opts) {
  var _HTTP_METHOD_PROCEDUR;

  const {
    req,
    res,
    createContext,
    teardown,
    onError,
    maxBodySize,
    subscriptions
  } = opts;

  if (req.method === 'HEAD') {
    // can be used for lambda warmup
    res.statusCode = 204;
    res.end();
    return;
  }

  if (opts.transformer) {
    once.deprecateTransformWarning();
  }

  const type = (_HTTP_METHOD_PROCEDUR = HTTP_METHOD_PROCEDURE_TYPE_MAP[req.method]) !== null && _HTTP_METHOD_PROCEDUR !== void 0 ? _HTTP_METHOD_PROCEDUR : 'unknown';
  let input = undefined;
  let ctx = undefined; // backwards compat - add transformer to router
  // TODO - remove in next major

  const router = opts.transformer ? opts.router.transformer(opts.transformer) : opts.router;
  const reqQueryParams = req.query ? req.query : url__default['default'].parse(req.url, true).query;
  const isBatchCall = reqQueryParams.batch;

  function endResponse(json) {
    if (Array.isArray(json)) {
      const allCodes = Array.from(new Set(json.map(res => res.statusCode)));
      const statusCode = allCodes.length === 1 ? allCodes[0] : 207;
      res.statusCode = statusCode;
    } else {
      res.statusCode = json.statusCode;
    }

    res.setHeader('Content-Type', 'application/json');
    res.end(JSON.stringify(router._def.transformer.serialize(json)));
  }

  try {
    var _opts$batching;

    if (isBatchCall && !((_opts$batching = opts.batching) !== null && _opts$batching !== void 0 && _opts$batching.enabled)) {
      throw new Error(`Batching is not enabled on the server`);
    }

    if (type === 'unknown') {
      throw new HTTPError(`Unexpected request method ${req.method}`, {
        statusCode: 405,
        code: 'BAD_USER_INPUT'
      });
    }

    const rawInput = await getInputFromRequest({
      maxBodySize,
      req,
      type
    });
    input = rawInput !== undefined ? router._def.transformer.deserialize(rawInput) : undefined;
    ctx = await (createContext === null || createContext === void 0 ? void 0 : createContext({
      req,
      res
    }));
    const caller = router.createCaller(ctx);

    const getInputs = () => {
      if (!isBatchCall) {
        return [input];
      }

      if (!Array.isArray(input)) {
        throw httpError.badRequest('"input" needs to be an array when doing a batch call');
      }

      return input;
    };

    const inputs = getInputs();
    const paths = isBatchCall ? opts.path.split(',') : [opts.path];
    const events = req;
    const results = await Promise.all(paths.map(async (path, index) => {
      try {
        var _res$statusCode;

        const output = await callProcedure({
          caller,
          path,
          input: inputs[index],
          events,
          subscriptions,
          type
        });
        const json = {
          ok: true,
          statusCode: (_res$statusCode = res.statusCode) !== null && _res$statusCode !== void 0 ? _res$statusCode : 200,
          data: output
        };
        events.emit('flush'); // `flush()` is used for subscriptions to flush out current output

        return json;
      } catch (_err) {
        const error = once.getErrorFromUnknown(_err);
        const json = {
          ok: false,
          statusCode: getStatusCodeFromError(error),
          error: router.getErrorShape({
            error,
            type,
            path,
            input,
            ctx
          })
        };
        res.statusCode = json.statusCode;
        onError && onError({
          error,
          path,
          input,
          ctx,
          type: type,
          req
        });
        return json;
      }
    }));
    const result = isBatchCall ? results : results[0];
    endResponse(result);
  } catch (_err) {
    const error = once.getErrorFromUnknown(_err);
    const json = {
      ok: false,
      statusCode: getStatusCodeFromError(error),
      error: router.getErrorShape({
        error,
        type,
        path: undefined,
        input,
        ctx
      })
    };
    endResponse(json);
    onError && onError({
      error,
      path: undefined,
      input,
      ctx,
      type: type,
      req
    });
  }

  try {
    teardown && (await teardown());
  } catch (err) {
    throw new Error('Teardown failed ' + (err === null || err === void 0 ? void 0 : err.message));
  }
}

/* eslint-disable @typescript-eslint/no-non-null-assertion */
assertNotBrowser();

exports.HTTPError = HTTPError;
exports.assertNotBrowser = assertNotBrowser;
exports.getStatusCodeFromError = getStatusCodeFromError;
exports.httpError = httpError;
exports.requestHandler = requestHandler;
