'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var once = require('../../dist/once-34ddee5a.cjs.dev.js');
var subscription = require('../../dist/subscription-de7af866.cjs.dev.js');
require('events');

const WEBSOCKET_STATUS_CODES = {
  ABNORMAL_CLOSURE: 1006
}; // json rpc 2 reference
// --> {"jsonrpc": "2.0", "method": "subtract", "params": [42, 23], "id": 1}
// <-- {"jsonrpc": "2.0", "result": 19, "id": 1}
// --> {"jsonrpc": "2.0", "method": "call", "params": [{type: x, 23]], "id": 1}

/* istanbul ignore next */
function assertIsObject(obj) {
  if (typeof obj !== 'object' || Array.isArray(obj) || !obj) {
    throw new Error('Not an object');
  }
}
/* istanbul ignore next */


function assertIsProcedureType(obj) {
  if (obj !== 'query' && obj !== 'subscription' && obj !== 'mutation') {
    throw new Error('Invalid procedure type');
  }
}
/* istanbul ignore next */


function assertIsRequestId(obj) {
  if (typeof obj !== 'number' || isNaN(obj)) {
    throw new Error('Invalid requestId');
  }
}
/* istanbul ignore next */


function assertIsString(obj) {
  if (typeof obj !== 'string') {
    throw new Error('Invalid string');
  }
}

function parseMessage(message) {
  assertIsString(message);
  const obj = JSON.parse(message);
  assertIsObject(obj);
  const {
    method,
    params,
    id
  } = obj;
  assertIsRequestId(id);

  if (method === 'stop') {
    return {
      type: 'stop',
      id
    };
  }

  assertIsProcedureType(method);
  assertIsObject(params);
  const {
    input,
    path
  } = params;
  assertIsString(path);
  return {
    type: method,
    id,
    input,
    path
  };
}

async function callProcedure(opts) {
  const {
    type,
    path,
    input,
    caller
  } = opts;

  if (type === 'query') {
    return caller.query(path, input);
  }

  if (type === 'mutation') {
    return caller.mutation(path, input);
  }

  if (type === 'subscription') {
    const sub = await caller.subscription(path, input);
    return sub;
  }
  /* istanbul ignore next */


  throw new Error(`Unknown procedure type ${type}`);
}
/**
 * Web socket server handler
 */


function applyWSSHandler(opts) {
  const {
    wss,
    createContext
  } = opts;

  if (opts.transformer) {
    once.deprecateTransformWarning();
  } // backwards compat - add transformer to router
  // TODO - remove in next major


  const router = opts.transformer ? opts.router.transformer(opts.transformer) : opts.router;
  const {
    transformer
  } = router._def;
  wss.on('connection', async (client, req) => {
    const clientSubscriptions = new Map();

    try {
      const ctx = await createContext({
        req,
        res: client
      });
      const caller = router.createCaller(ctx);
      client.on('message', async message => {
        function respond(id, result) {
          const response = {
            jsonrpc: '2.0',
            result: transformer.serialize(result),
            id
          };
          client.send(JSON.stringify(response));
        }

        const info = parseMessage(message);
        const input = typeof info.input !== 'undefined' ? transformer.deserialize(info.input) : undefined;

        if (info.type === 'stop') {
          var _clientSubscriptions$;

          (_clientSubscriptions$ = clientSubscriptions.get(info.id)) === null || _clientSubscriptions$ === void 0 ? void 0 : _clientSubscriptions$.destroy();
          clientSubscriptions.delete(info.id);
          return;
        }

        const {
          path,
          type,
          id
        } = info;

        try {
          const result = await callProcedure({
            path,
            input,
            type,
            caller
          });

          if (result instanceof subscription.Subscription) {
            const sub = result;
            /* istanbul ignore next */

            if (client.readyState !== client.OPEN) {
              // if the client got disconnected whilst initializing the subscription
              sub.destroy();
              return;
            }
            /* istanbul ignore next */


            if (clientSubscriptions.has(id)) {
              // duplicate request ids for client
              sub.destroy();
              throw new Error(`Duplicate id ${id}`);
            }

            clientSubscriptions.set(id, sub);
            sub.on('data', data => {
              respond(id, {
                ok: true,
                data
              });
            });
            sub.on('error', _error => {
              var _opts$onError;

              const error = once.getErrorFromUnknown(_error);
              const json = {
                ok: false,
                error: router.getErrorShape({
                  error,
                  type,
                  path,
                  input,
                  ctx
                })
              };
              (_opts$onError = opts.onError) === null || _opts$onError === void 0 ? void 0 : _opts$onError.call(opts, {
                error,
                path,
                type,
                ctx,
                req,
                input
              }); // TODO trigger some global error handler?

              respond(id, json);
            });
            sub.on('destroy', () => {
              const response = {
                jsonrpc: '2.0',
                id,
                result: 'stopped'
              };
              client.send(JSON.stringify(response));
            });
            await sub.start(); // FIXME handle errors? or not? maybe push it to a callback with the ws client

            return;
          }

          respond(id, {
            ok: true,
            data: result
          });
        } catch (error)
        /* istanbul ignore next */
        {
          var _opts$onError2;

          // procedure threw an error
          const json = {
            ok: false,
            error: router.getErrorShape({
              error,
              type,
              path,
              input,
              ctx
            })
          };
          (_opts$onError2 = opts.onError) === null || _opts$onError2 === void 0 ? void 0 : _opts$onError2.call(opts, {
            error,
            path,
            type,
            ctx,
            req,
            input
          });
          respond(id, json);
        }
      });
      client.once('close', () => {
        for (const sub of clientSubscriptions.values()) {
          sub.destroy();
        }

        clientSubscriptions.clear();
      });
    } catch (err)
    /* istanbul ignore next */
    {
      var _opts$onError3;

      // failed to create context
      const error = once.getErrorFromUnknown(err);
      const json = {
        ok: false,
        error: router.getErrorShape({
          error,
          type: 'unknown',
          path: undefined,
          input: undefined,
          ctx: undefined
        })
      };
      client.send(json);
      (_opts$onError3 = opts.onError) === null || _opts$onError3 === void 0 ? void 0 : _opts$onError3.call(opts, {
        error,
        path: undefined,
        type: 'unknown',
        ctx: undefined,
        req,
        input: undefined
      });
      client.close(WEBSOCKET_STATUS_CODES.ABNORMAL_CLOSURE);
    }
  });
  return {
    reconnectAllClients: () => {
      const response = {
        jsonrpc: '2.0',
        result: 'reconnect',
        id: -1
      };
      const data = JSON.stringify(response);

      for (const client of wss.clients) {
        if (client.readyState === 1
        /* ws.OPEN */
        ) {
            client.send(data);
          }
      }
    }
  };
}

exports.applyWSSHandler = applyWSSHandler;
