import { T as TRPCClientError, h as httpRequest } from '../../../dist/createTRPCClient-4c16be1e.esm.js';
import _createForOfIteratorHelper from '@babel/runtime/helpers/esm/createForOfIteratorHelper';
import '@babel/runtime/helpers/asyncToGenerator';
import '@babel/runtime/helpers/toConsumableArray';
import '@babel/runtime/helpers/objectSpread2';
import '@babel/runtime/helpers/classCallCheck';
import '@babel/runtime/helpers/createClass';
import '@babel/runtime/helpers/assertThisInitialized';
import '@babel/runtime/helpers/inherits';
import '@babel/runtime/helpers/createSuper';
import '@babel/runtime/helpers/wrapNativeSuper';
import '@babel/runtime/regenerator';

/**
 * Dataloader that's very inspired by https://github.com/graphql/dataloader
 * Less configuration, no caching, and allows you to cancel requests
 * When cancelling a single fetch the whole batch will be cancelled only when _all_ items are cancelled
 */
function dataLoader(fetchMany) {
  var batch = null;
  var dispatchTimer = null;

  var destroyTimerAndBatch = function destroyTimerAndBatch() {
    clearTimeout(dispatchTimer);
    dispatchTimer = null;
    batch = null;
  };

  function dispatch() {
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    var batchCopy = batch;
    destroyTimerAndBatch();

    var _fetchMany = fetchMany(batchCopy.items.map(function (v) {
      return v.key;
    })),
        promise = _fetchMany.promise,
        cancel = _fetchMany.cancel;

    batchCopy.cancel = cancel;
    promise.then(function (result) {
      for (var i = 0; i < result.length; i++) {
        var _value = result[i];
        batchCopy.items[i].resolve(_value);
      }
    }).catch(function (error) {
      var _iterator = _createForOfIteratorHelper(batchCopy.items),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var item = _step.value;
          item.reject(error);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    });
  }

  function load(key) {
    var batchItem = {
      cancelled: false,
      key: key
    };

    if (!batch) {
      batch = {
        items: [],
        cancel: function cancel() {
          destroyTimerAndBatch();
        }
      };
    }

    var thisBatch = batch;
    var promise = new Promise(function (resolve, reject) {
      var item = batchItem;
      item.reject = reject;
      item.resolve = resolve;
      thisBatch.items.push(item);
    });

    if (!dispatchTimer) {
      dispatchTimer = setTimeout(dispatch);
    }

    var cancel = function cancel() {
      batchItem.cancelled = true;

      if (thisBatch.items.some(function (item) {
        return !item.cancelled;
      })) {
        // there are still things that can be resolved
        return;
      }

      thisBatch.cancel();
    };

    return {
      promise: promise,
      cancel: cancel
    };
  }

  return {
    load: load
  };
}

function httpBatchLink(opts) {
  var url = opts.url; // initialized config

  return function (runtime) {
    // initialized in app
    var fetcher = function fetcher(type) {
      return function (keyInputPairs) {
        var path = keyInputPairs.map(function (_ref) {
          var path = _ref.path;
          return path;
        }).join(',');
        var input = keyInputPairs.map(function (_ref2) {
          var input = _ref2.input;
          return input;
        });

        var _httpRequest = httpRequest({
          url: url,
          input: input,
          path: path,
          runtime: runtime,
          type: type,
          searchParams: 'batch=1'
        }),
            promise = _httpRequest.promise,
            cancel = _httpRequest.cancel;

        return {
          promise: promise.then(function (res) {
            if (!Array.isArray(res)) {
              return keyInputPairs.map(function () {
                return res;
              });
            }

            return res;
          }),
          cancel: cancel
        };
      };
    };

    var query = dataLoader(fetcher('query'));
    var mutation = dataLoader(fetcher('mutation'));
    var subscription = dataLoader(fetcher('subscription'));
    var loaders = {
      query: query,
      subscription: subscription,
      mutation: mutation
    };
    return function (_ref3) {
      var op = _ref3.op,
          prev = _ref3.prev,
          onDestroy = _ref3.onDestroy;
      var loader = loaders[op.type];

      var _loader$load = loader.load(op),
          promise = _loader$load.promise,
          cancel = _loader$load.cancel;

      var done = false;
      onDestroy(function () {
        if (!done) {
          prev(TRPCClientError.from(new DOMException('The operation was aborted.', 'AbortError')));
        }

        done = true;
        cancel();
      });
      promise.then(function (result) {
        if (!done) {
          prev(result.ok ? result : TRPCClientError.from(result));
        }
      }).catch(function (err) {
        if (!done) {
          prev(TRPCClientError.from(err));
        }
      }).finally(function () {
        done = true;
      });
    };
  };
}

export { httpBatchLink };
