'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _classCallCheck = require('@babel/runtime/helpers/classCallCheck');
var _assertThisInitialized = require('@babel/runtime/helpers/assertThisInitialized');
var _inherits = require('@babel/runtime/helpers/inherits');
var _createSuper = require('@babel/runtime/helpers/createSuper');
var _wrapNativeSuper = require('@babel/runtime/helpers/wrapNativeSuper');
var links_httpLink_dist_trpcClientLinksHttpLink = require('../../../dist/createTRPCClient-de71d968.cjs.dev.js');
require('@babel/runtime/helpers/asyncToGenerator');
require('@babel/runtime/helpers/toConsumableArray');
require('@babel/runtime/helpers/objectSpread2');
require('@babel/runtime/helpers/createClass');
require('@babel/runtime/regenerator');
require('@babel/runtime/helpers/createForOfIteratorHelper');

function createWSClient(opts) {
  var url = opts.url,
      _opts$WebSocket = opts.WebSocket,
      WebSocketImpl = _opts$WebSocket === void 0 ? WebSocket : _opts$WebSocket,
      _opts$retryDelayMs = opts.retryDelayMs,
      retryDelayFn = _opts$retryDelayMs === void 0 ? links_httpLink_dist_trpcClientLinksHttpLink.retryDelay : _opts$retryDelayMs,
      _opts$staleConnection = opts.staleConnectionTimeoutMs,
      staleConnectionTimeoutMs = _opts$staleConnection === void 0 ? 1000 : _opts$staleConnection,
      _opts$reconnectDelayM = opts.reconnectDelayMs,
      reconnectDelayMs = _opts$reconnectDelayM === void 0 ? function () {
    return 0;
  } : _opts$reconnectDelayM;
  /* istanbul ignore next */

  if (!WebSocketImpl) {
    throw new Error("No WebSocket implementation found - you probably don't want to use this on the server, but if you do you need to pass a `WebSocket`-ponyfill");
  }

  var idCounter = 0;
  var isClosed = false;
  /**
   * outgoing messages buffer whilst not open
   */

  var outgoing = [];
  /**
   * pending outgoing requests that are awaiting callback
   */

  var pendingRequests = Object.create(null);
  var connectAttempt = 0;
  var connectTimer = null;
  var activeConnection = createWS();
  var state = 'connecting';
  /**
   * tries to send the list of messages
   */

  function triggerSendIfConnected() {
    if (state !== 'open') {
      return;
    }

    while (true) {
      var msg = outgoing.shift();

      if (!msg) {
        break;
      }

      activeConnection.send(JSON.stringify(msg));
    }
  }

  function tryReconnect() {
    if (connectTimer || isClosed) {
      return;
    }

    var timeout = retryDelayFn(connectAttempt++);
    reconnectInMs(timeout);
  }

  function reconnectInMs(ms) {
    clearTimeout(connectTimer);
    state = 'connecting';
    var oldConnection = activeConnection;
    setTimeout(function () {
      oldConnection.close();
    }, staleConnectionTimeoutMs);
    connectTimer = setTimeout(function () {
      activeConnection = createWS();
    }, ms);
  }

  function closeIfNoPending(conn) {
    // disconnect as soon as there are no pending queries /  mutations
    var hasPendingRequests = Object.values(pendingRequests).some(function (p) {
      return p.ws === conn && p.type !== 'subscription';
    });

    if (!hasPendingRequests) {
      conn.close();
    }
  }

  function createWS() {
    var conn = new WebSocket(url);
    clearTimeout(connectTimer);
    connectTimer = null;
    conn.addEventListener('open', function () {
      connectAttempt = 0;
      state = 'open';
      triggerSendIfConnected();
    });
    conn.addEventListener('error', function () {
      tryReconnect();
    });
    conn.addEventListener('message', function (msg) {
      var res = JSON.parse(msg.data);

      if (conn !== activeConnection) {
        setTimeout(function () {
          closeIfNoPending(conn);
        }, 1);
      }

      if (res.result === 'reconnect' && conn === activeConnection) {
        reconnectInMs(reconnectDelayMs());
        return;
      }

      var req = pendingRequests[res.id];

      if (!req) {
        // do something?
        return;
      }

      if (res.result === 'stopped') {
        var _req$callbacks$onDone, _req$callbacks;

        delete pendingRequests[res.id];
        (_req$callbacks$onDone = (_req$callbacks = req.callbacks).onDone) === null || _req$callbacks$onDone === void 0 ? void 0 : _req$callbacks$onDone.call(_req$callbacks);
      } else {
        var _req$callbacks$onNext, _req$callbacks2;

        (_req$callbacks$onNext = (_req$callbacks2 = req.callbacks).onNext) === null || _req$callbacks$onNext === void 0 ? void 0 : _req$callbacks$onNext.call(_req$callbacks2, res);
      }
    });
    conn.addEventListener('close', function () {
      if (activeConnection === conn) {
        // connection might have been replaced already
        tryReconnect();
      }

      for (var key in pendingRequests) {
        var req = pendingRequests[key];

        if (req.ws === conn) {
          var _req$callbacks$onDone2, _req$callbacks3;

          delete pendingRequests[key];
          (_req$callbacks$onDone2 = (_req$callbacks3 = req.callbacks).onDone) === null || _req$callbacks$onDone2 === void 0 ? void 0 : _req$callbacks$onDone2.call(_req$callbacks3);
        }
      }
    });
    return conn;
  }

  function request(op, callbacks) {
    var type = op.type,
        input = op.input,
        path = op.path;
    var id = ++idCounter;
    var envelope = {
      id: id,
      jsonrpc: '2.0',
      method: type,
      params: {
        input: input,
        path: path
      }
    };
    pendingRequests[id] = {
      ws: activeConnection,
      type: type,
      callbacks: callbacks
    }; // enqueue message

    outgoing.push(envelope);
    triggerSendIfConnected();
    return function () {
      var _pendingRequests$id, _pendingRequests$id$c, _pendingRequests$id$c2;

      (_pendingRequests$id = pendingRequests[id]) === null || _pendingRequests$id === void 0 ? void 0 : (_pendingRequests$id$c = (_pendingRequests$id$c2 = _pendingRequests$id.callbacks).onDone) === null || _pendingRequests$id$c === void 0 ? void 0 : _pendingRequests$id$c.call(_pendingRequests$id$c2);
      delete pendingRequests[id];

      if (op.type === 'subscription') {
        outgoing.push({
          id: id,
          method: 'stop',
          jsonrpc: '2.0'
        });
        triggerSendIfConnected();
      }
    };
  }

  return {
    close: function close() {
      isClosed = true;
      closeIfNoPending(activeConnection);
    },
    request: request,
    getConnection: function getConnection() {
      return activeConnection;
    }
  };
}
var WebSocketInterruptedError = /*#__PURE__*/function (_Error) {
  _inherits(WebSocketInterruptedError, _Error);

  var _super = /*#__PURE__*/_createSuper(WebSocketInterruptedError);

  function WebSocketInterruptedError(message) {
    var _this;

    _classCallCheck(this, WebSocketInterruptedError);

    _this = _super.call(this, message);
    Object.setPrototypeOf(_assertThisInitialized(_this), WebSocketInterruptedError.prototype);
    return _this;
  }

  return WebSocketInterruptedError;
}( /*#__PURE__*/_wrapNativeSuper(Error));
function wsLink(opts) {
  // initialized config
  return function (rt) {
    var client = opts.client;
    return function (_ref) {
      var op = _ref.op,
          prev = _ref.prev,
          onDestroy = _ref.onDestroy;
      var type = op.type,
          rawInput = op.input,
          path = op.path;
      var input = rt.transformer.serialize(rawInput);
      var unsubbed = false;
      var unsub = client.request({
        type: type,
        path: path,
        input: input
      }, {
        onNext: function onNext(envelope) {
          var data = rt.transformer.deserialize(envelope.result);
          prev(data.ok ? data : links_httpLink_dist_trpcClientLinksHttpLink.TRPCClientError.from(data));

          if (op.type !== 'subscription') {
            // if it isn't a subscription we don't care about next response
            unsubbed = true;
            unsub();
          }
        },
        // // FIXME
        // onError() {
        // },
        onDone: function onDone() {
          if (!unsubbed) {
            prev(links_httpLink_dist_trpcClientLinksHttpLink.TRPCClientError.from(new WebSocketInterruptedError('Operation ended prematurely'), {
              isDone: true
            }));
          }
        }
      });
      onDestroy(function () {
        unsubbed = true;
        unsub();
      });
    };
  };
}

exports.WebSocketInterruptedError = WebSocketInterruptedError;
exports.createWSClient = createWSClient;
exports.wsLink = wsLink;
