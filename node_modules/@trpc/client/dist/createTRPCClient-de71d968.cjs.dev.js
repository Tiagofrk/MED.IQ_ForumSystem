'use strict';

var _asyncToGenerator = require('@babel/runtime/helpers/asyncToGenerator');
var _toConsumableArray = require('@babel/runtime/helpers/toConsumableArray');
var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var _classCallCheck = require('@babel/runtime/helpers/classCallCheck');
var _createClass = require('@babel/runtime/helpers/createClass');
var _assertThisInitialized = require('@babel/runtime/helpers/assertThisInitialized');
var _inherits = require('@babel/runtime/helpers/inherits');
var _createSuper = require('@babel/runtime/helpers/createSuper');
var _wrapNativeSuper = require('@babel/runtime/helpers/wrapNativeSuper');
var _regeneratorRuntime = require('@babel/runtime/regenerator');
var _createForOfIteratorHelper = require('@babel/runtime/helpers/createForOfIteratorHelper');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var _regeneratorRuntime__default = /*#__PURE__*/_interopDefault(_regeneratorRuntime);

function observable() {
  var listeners = [];
  var value = null;
  return {
    subscribe: function subscribe(callbacks) {
      var listener = {
        callbacks: callbacks,
        unsubscribe: function unsubscribe() {
          var index = listeners.indexOf(listener);

          if (index !== -1) {
            var _listener$callbacks$o, _listener$callbacks;

            listeners.splice(index, 1);
            (_listener$callbacks$o = (_listener$callbacks = listener.callbacks).onDone) === null || _listener$callbacks$o === void 0 ? void 0 : _listener$callbacks$o.call(_listener$callbacks);
          }
        }
      };
      listeners.push(listener);
      return function () {
        listener.unsubscribe();
      };
    },
    next: function next(newValue) {
      var oldValue = value;
      value = newValue;

      if (oldValue !== newValue) {
        var _iterator = _createForOfIteratorHelper(listeners),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _listener$callbacks$o2, _listener$callbacks2;

            var listener = _step.value;
            (_listener$callbacks$o2 = (_listener$callbacks2 = listener.callbacks).onNext) === null || _listener$callbacks$o2 === void 0 ? void 0 : _listener$callbacks$o2.call(_listener$callbacks2, newValue);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    },
    done: function done() {
      while (listeners.length) {
        var _listener$callbacks$o3, _listener$callbacks3;

        var listener = listeners.pop();
        listener === null || listener === void 0 ? void 0 : (_listener$callbacks$o3 = (_listener$callbacks3 = listener.callbacks).onDone) === null || _listener$callbacks$o3 === void 0 ? void 0 : _listener$callbacks$o3.call(_listener$callbacks3);
        listener === null || listener === void 0 ? void 0 : listener.unsubscribe();
      }
    },
    error: function (_error) {
      function error(_x) {
        return _error.apply(this, arguments);
      }

      error.toString = function () {
        return _error.toString();
      };

      return error;
    }(function (error) {
      var _iterator2 = _createForOfIteratorHelper(listeners),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _listener$callbacks$o4, _listener$callbacks4;

          var listener = _step2.value;
          (_listener$callbacks$o4 = (_listener$callbacks4 = listener.callbacks).onError) === null || _listener$callbacks$o4 === void 0 ? void 0 : _listener$callbacks$o4.call(_listener$callbacks4, error);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    })
  };
}
function observableSubject(initialValue) {
  var $obs = observable();
  var value = initialValue;
  $obs.next(initialValue);
  return _objectSpread(_objectSpread({}, $obs), {}, {
    next: function next(v) {
      value = v;
      $obs.next(v);
    },
    get: function get() {
      return value;
    }
  });
}

function executeChain(opts) {
  var $result = observableSubject({
    type: 'init'
  });
  var $destroyed = observableSubject(false);

  var updateResult = function updateResult(result) {
    if (result instanceof Error) {
      $result.error(result);

      if (result.isDone) {
        $result.done();
      }
    } else {
      $result.next({
        type: 'data',
        data: result.data
      });
    }
  };

  function walk(_ref) {
    var index = _ref.index,
        op = _ref.op,
        stack = _ref.stack;
    var link = opts.links[index];
    var prev = index === 0 ? function (value) {
      return updateResult(value);
    } : stack[index - 1];
    link({
      op: op,
      prev: prev,
      next: function next(op, prevOp) {
        var prevStack = stack.slice();
        prevStack[index] = prevOp;
        walk({
          index: index + 1,
          op: op,
          stack: prevStack
        });
      },
      onDestroy: function onDestroy(callback) {
        var unsub = $destroyed.subscribe({
          onNext: function onNext(aborted) {
            if (aborted) {
              callback();
              unsub();
            }
          }
        });
      }
    });
  }

  walk({
    index: 0,
    op: opts.op,
    stack: []
  });
  $result.subscribe({
    onError: function onError(err) {
      var _err$originalError;

      if (((_err$originalError = err.originalError) === null || _err$originalError === void 0 ? void 0 : _err$originalError.name) === 'TRPCAbortErrorSignal') {
        $destroyed.next(true);
      }
    },
    onDone: function onDone() {
      $destroyed.next(true);
    }
  });
  return $result;
}

function getWindow() {
  if (typeof window !== 'undefined') {
    return window;
  }

  return global;
}

function getAbortController(ac) {
  var win = getWindow();
  return ac || win.AbortController || null;
}
function getFetch(f) {
  if (f) {
    return f;
  }

  var win = getWindow();

  if (win.fetch) {
    return typeof win.fetch.bind === 'function' ? win.fetch.bind(win) : win.fetch;
  }

  throw new Error('No fetch implementation found');
}

/* istanbul ignore next */
var retryDelay = function retryDelay(attemptIndex) {
  return attemptIndex === 0 ? 0 : Math.min(1000 * Math.pow(2, attemptIndex), 30000);
};

function httpRequest(props) {
  var type = props.type,
      rt = props.runtime,
      input = props.input,
      path = props.path;
  var ac = rt.AbortController ? new rt.AbortController() : null;
  var method = {
    query: 'GET',
    mutation: 'POST',
    subscription: 'PATCH'
  };

  function getUrl() {
    var url = props.url + '/' + path;
    var queryParts = [];

    if (props.searchParams) {
      queryParts.push(props.searchParams);
    }

    if (type === 'query' && input != null) {
      queryParts.push("input=".concat(encodeURIComponent(JSON.stringify(rt.transformer.serialize(input)))));
    }

    if (queryParts.length) {
      url += '?' + queryParts.join('&');
    }

    return url;
  }

  function getBody() {
    if (type === 'query') {
      return undefined;
    }

    return JSON.stringify({
      input: rt.transformer.serialize(input)
    });
  }

  var promise = new Promise(function (resolve, reject) {
    var url = getUrl();
    rt.fetch(url, {
      method: method[type],
      signal: ac === null || ac === void 0 ? void 0 : ac.signal,
      body: getBody(),
      headers: _objectSpread({
        'content-type': 'application/json'
      }, rt.headers())
    }).then(function (res) {
      return res.json();
    }).then(function (json) {
      resolve(rt.transformer.deserialize(json));
    }).catch(reject);
  });

  var cancel = function cancel() {
    ac === null || ac === void 0 ? void 0 : ac.abort();
  };

  return {
    promise: promise,
    cancel: cancel
  };
}

function httpLink(opts) {
  var url = opts.url; // initialized config

  return function (runtime) {
    // initialized in app
    return function (_ref) {
      var op = _ref.op,
          prev = _ref.prev,
          onDestroy = _ref.onDestroy;
      var path = op.path,
          input = op.input,
          type = op.type;

      var _httpRequest = httpRequest({
        runtime: runtime,
        type: type,
        input: input,
        url: url,
        path: path
      }),
          promise = _httpRequest.promise,
          cancel = _httpRequest.cancel;

      onDestroy(function () {
        cancel();
      });
      promise.then(function (result) {
        return prev(result.ok ? result : TRPCClientError.from(result));
      }).catch(function (err) {
        return prev(TRPCClientError.from(err));
      });
    };
  };
}

var TRPCAbortErrorSignal = /*#__PURE__*/function (_Error) {
  _inherits(TRPCAbortErrorSignal, _Error);

  var _super = /*#__PURE__*/_createSuper(TRPCAbortErrorSignal);

  function TRPCAbortErrorSignal() {
    var _this;

    _classCallCheck(this, TRPCAbortErrorSignal);

    _this = _super.call(this, 'TRPCAbortErrorSignal');
    _this.name = 'TRPCAbortErrorSignal';
    Object.setPrototypeOf(_assertThisInitialized(_this), TRPCAbortErrorSignal.prototype);
    return _this;
  }

  return TRPCAbortErrorSignal;
}( /*#__PURE__*/_wrapNativeSuper(Error));

var TRPCClientError = /*#__PURE__*/function (_Error) {
  _inherits(TRPCClientError, _Error);

  var _super = /*#__PURE__*/_createSuper(TRPCClientError);

  /**
   * Fatal error - expect no more results after this error
   */
  function TRPCClientError(message, _ref) {
    var _this$result;

    var _this;

    var result = _ref.result,
        originalError = _ref.originalError,
        _ref$isDone = _ref.isDone,
        isDone = _ref$isDone === void 0 ? false : _ref$isDone;

    _classCallCheck(this, TRPCClientError);

    _this = _super.call(this, message);
    _this.result = void 0;
    _this.res = void 0;
    _this.originalError = void 0;
    _this.shape = void 0;
    _this.isDone = void 0;
    _this.isDone = isDone;
    _this.message = message;
    _this.result = result;
    _this.originalError = originalError;
    _this.shape = (_this$result = _this.result) === null || _this$result === void 0 ? void 0 : _this$result.error;
    _this.name = 'TRPCClientError';
    Object.setPrototypeOf(_assertThisInitialized(_this), TRPCClientError.prototype);
    return _this;
  }

  _createClass(TRPCClientError, null, [{
    key: "from",
    value: function from(result) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!(result instanceof Error)) {
        var _message;

        return new TRPCClientError((_message = result.error.message) !== null && _message !== void 0 ? _message : '', _objectSpread(_objectSpread({}, opts), {}, {
          originalError: null,
          result: result
        }));
      }

      if (result.name === 'TRPCClientError') {
        return result;
      }

      return new TRPCClientError(result.message, _objectSpread(_objectSpread({}, opts), {}, {
        originalError: result,
        result: null
      }));
    }
  }]);

  return TRPCClientError;
}( /*#__PURE__*/_wrapNativeSuper(Error));
var TRPCClient = /*#__PURE__*/function () {
  function TRPCClient(opts) {
    var _opts$fetchOpts,
        _opts$fetchOpts2,
        _this2 = this;

    _classCallCheck(this, TRPCClient);

    this.links = void 0;
    this.runtime = void 0;
    this.opts = void 0;
    this.opts = opts;
    var transformer = opts.transformer ? 'input' in opts.transformer ? {
      serialize: opts.transformer.input.serialize,
      deserialize: opts.transformer.output.deserialize
    } : opts.transformer : {
      serialize: function serialize(data) {
        return data;
      },
      deserialize: function deserialize(data) {
        return data;
      }
    };

    var _fetch = getFetch((_opts$fetchOpts = opts.fetchOpts) === null || _opts$fetchOpts === void 0 ? void 0 : _opts$fetchOpts.fetch);

    var AC = getAbortController((_opts$fetchOpts2 = opts.fetchOpts) === null || _opts$fetchOpts2 === void 0 ? void 0 : _opts$fetchOpts2.AbortController);

    function getHeadersFn() {
      if (opts.headers) {
        var headers = opts.headers;
        return typeof headers === 'function' ? headers : function () {
          return headers;
        };
      }

      return function () {
        return {};
      };
    }

    this.runtime = {
      transformer: transformer,
      AbortController: AC,
      fetch: _fetch,
      headers: getHeadersFn()
    };

    if ('links' in opts) {
      this.links = opts.links.map(function (link) {
        return link(_this2.runtime);
      });
    } else {
      this.links = [httpLink({
        url: opts.url
      })(this.runtime)];
    }
    /**
     * @deprecated
     * prepending a link to call `onSuccess` / `onError`
     */


    if (this.opts.onError || this.opts.onError) {
      // deprecation warning?
      this.links = [function (_ref2) {
        var op = _ref2.op,
            next = _ref2.next,
            prev = _ref2.prev;
        next(op, function (result) {
          var _this2$opts, _this2$opts$onError, _this2$opts2, _this2$opts2$onSucces;

          result instanceof Error ? (_this2$opts = _this2.opts) === null || _this2$opts === void 0 ? void 0 : (_this2$opts$onError = _this2$opts.onError) === null || _this2$opts$onError === void 0 ? void 0 : _this2$opts$onError.call(_this2$opts, result) : (_this2$opts2 = _this2.opts) === null || _this2$opts2 === void 0 ? void 0 : (_this2$opts2$onSucces = _this2$opts2.onSuccess) === null || _this2$opts2$onSucces === void 0 ? void 0 : _this2$opts2$onSucces.call(_this2$opts2, result);
          prev(result);
        });
      }].concat(_toConsumableArray(this.links));
    }
  }
  /**
   * @deprecated will be turned private
   */


  _createClass(TRPCClient, [{
    key: "request",
    value: function request(opts) {
      return this.requestAsPromise(opts);
    }
  }, {
    key: "$request",
    value: function $request(_ref3) {
      var type = _ref3.type,
          input = _ref3.input,
          path = _ref3.path,
          _ref3$context = _ref3.context,
          context = _ref3$context === void 0 ? {} : _ref3$context;
      var $result = executeChain({
        links: this.links,
        op: {
          type: type,
          path: path,
          input: input,
          context: context
        }
      });
      return $result;
    }
  }, {
    key: "requestAsPromise",
    value: function requestAsPromise(opts) {
      var $result = this.$request(opts);
      var promise = new Promise(function (resolve, reject) {
        var res = $result.get();

        if (res.type === 'data') {
          resolve(res.data);
          $result.done();
          return;
        }

        $result.subscribe({
          onNext: function onNext(result) {
            if (result.type !== 'data') {
              return;
            }

            resolve(result.data);
            $result.done();
          },
          onError: function onError(err) {
            var _err$originalError;

            // this is used to bubble up to the ending link
            if (((_err$originalError = err.originalError) === null || _err$originalError === void 0 ? void 0 : _err$originalError.name) !== 'TRPCAbortErrorSignal') {
              reject(err);
              $result.done();
            }
          }
        });
      });

      promise.cancel = function () {
        $result.error(TRPCClientError.from(new TRPCAbortErrorSignal()));
      };

      return promise;
    }
  }, {
    key: "query",
    value: function query(path) {
      var _ref4;

      var context = (_ref4 = arguments.length <= 2 ? undefined : arguments[2]) === null || _ref4 === void 0 ? void 0 : _ref4.context;
      return this.requestAsPromise({
        type: 'query',
        path: path,
        input: arguments.length <= 1 ? undefined : arguments[1],
        context: context
      });
    }
  }, {
    key: "mutation",
    value: function mutation(path) {
      var _ref5;

      var context = (_ref5 = arguments.length <= 2 ? undefined : arguments[2]) === null || _ref5 === void 0 ? void 0 : _ref5.context;
      return this.requestAsPromise({
        type: 'mutation',
        path: path,
        input: arguments.length <= 1 ? undefined : arguments[1],
        context: context
      });
    }
    /* istanbul ignore next */

  }, {
    key: "subscriptionOnce",
    value: function subscriptionOnce(path, input, opts) {
      var _this3 = this;

      var stopped = false;
      var nextTry; // setting as `NodeJS.Timeout` causes compat issues, can probably be solved

      var currentRequest = null;
      var context = opts === null || opts === void 0 ? void 0 : opts.context;
      var promise = new Promise(function (resolve, reject) {
        var exec = /*#__PURE__*/function () {
          var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee() {
            var _data, _err2$result, _err2;

            return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (!stopped) {
                      _context.next = 2;
                      break;
                    }

                    return _context.abrupt("return");

                  case 2:
                    _context.prev = 2;
                    currentRequest = _this3.requestAsPromise({
                      type: 'subscription',
                      input: input,
                      path: path,
                      context: context
                    });
                    _context.next = 6;
                    return currentRequest;

                  case 6:
                    _data = _context.sent;
                    resolve(_data);
                    _context.next = 14;
                    break;

                  case 10:
                    _context.prev = 10;
                    _context.t0 = _context["catch"](2);
                    _err2 = _context.t0;

                    if (((_err2$result = _err2.result) === null || _err2$result === void 0 ? void 0 : _err2$result.statusCode) === 408) {
                      // server told us to reconnect
                      exec();
                    } else {
                      reject(_err2);
                    }

                  case 14:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, null, [[2, 10]]);
          }));

          return function exec() {
            return _ref6.apply(this, arguments);
          };
        }();

        exec();
      });

      promise.cancel = function () {
        var _currentRequest;

        stopped = true;
        clearTimeout(nextTry);
        ((_currentRequest = currentRequest) === null || _currentRequest === void 0 ? void 0 : _currentRequest.cancel) && currentRequest.cancel();
      };

      return promise;
    }
    /* istanbul ignore next */

    /**
     * @deprecated - legacy stuff for http subscriptions
     */

  }, {
    key: "subscription",
    value: function subscription(path, opts) {
      var _this4 = this;

      var stopped = false; // let nextTry: any; // setting as `NodeJS.Timeout` causes compat issues, can probably be solved

      var currentPromise = null;
      var attemptIndex = 0;

      var unsubscribe = function unsubscribe() {
        var _currentPromise;

        stopped = true;
        (_currentPromise = currentPromise) === null || _currentPromise === void 0 ? void 0 : _currentPromise.cancel();
        currentPromise = null;
      };

      var exec = /*#__PURE__*/function () {
        var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2(input) {
          var res, nextInput;
          return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.prev = 0;
                  currentPromise = _this4.subscriptionOnce(path, input);
                  _context2.next = 4;
                  return currentPromise;

                case 4:
                  res = _context2.sent;
                  attemptIndex = 0;
                  opts.onData && opts.onData(res);
                  nextInput = opts.nextInput(res);
                  exec(nextInput);
                  _context2.next = 18;
                  break;

                case 11:
                  _context2.prev = 11;
                  _context2.t0 = _context2["catch"](0);

                  if (!stopped) {
                    _context2.next = 15;
                    break;
                  }

                  return _context2.abrupt("return");

                case 15:
                  opts.onError && opts.onError(_context2.t0);
                  attemptIndex++;
                  setTimeout(function () {
                    exec(input);
                  }, retryDelay(attemptIndex));

                case 18:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, null, [[0, 11]]);
        }));

        return function exec(_x) {
          return _ref7.apply(this, arguments);
        };
      }();

      exec(opts.initialInput);
      return unsubscribe;
    }
    /* istanbul ignore next */

  }, {
    key: "$subscription",
    value: function $subscription(path, input, opts) {
      var $res = this.$request({
        type: 'subscription',
        path: path,
        input: input,
        context: opts.context
      });
      $res.subscribe({
        onNext: function onNext(output) {
          var _opts$onNext;

          output && output.type === 'data' && ((_opts$onNext = opts.onNext) === null || _opts$onNext === void 0 ? void 0 : _opts$onNext.call(opts, output.data));
        },
        onError: opts.onError,
        onDone: opts.onDone
      });
      return function () {
        $res.done();
      };
    }
  }]);

  return TRPCClient;
}();
function createTRPCClient(opts) {
  return new TRPCClient(opts);
}

exports.TRPCClient = TRPCClient;
exports.TRPCClientError = TRPCClientError;
exports.createTRPCClient = createTRPCClient;
exports.httpLink = httpLink;
exports.httpRequest = httpRequest;
exports.retryDelay = retryDelay;
